<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-C | Hank]]></title>
  <link href="http://bcswlmpke.github.com/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://bcswlmpke.github.com/"/>
  <updated>2012-11-25T13:58:06+08:00</updated>
  <id>http://bcswlmpke.github.com/</id>
  <author>
    <name><![CDATA[Hank Chen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UITableView 如何調整 Scroll Indicator 的位置？]]></title>
    <link href="http://bcswlmpke.github.com/blog/2012/10/17/change-uitable-scrollindicator-position/"/>
    <updated>2012-10-17T21:48:00+08:00</updated>
    <id>http://bcswlmpke.github.com/blog/2012/10/17/change-uitable-scrollindicator-position</id>
    <content type="html"><![CDATA[<p>嚴格說起來，應該是繼承自 UIScrollView 的都可以調整。
舉例來說，假設要顯示的是垂直方向的 Indicator (預設是開啟的)
<code>ruby
_tableView.showsVerticalScrollIndicator = YES;
</code>
預設位置是在 TableView 的最右邊，假設想放到左邊，或是中間，要怎麼做？
答案是：<code>UIEdgeInsets</code>
<code>ruby
top, left, bottom, right
</code>
接下來要怎麼調整，就看個人需求囉！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITableView 顯示上萬筆資料時，reloadData 很慢的問題]]></title>
    <link href="http://bcswlmpke.github.com/blog/2012/10/02/uitableview-reloaddata-slow/"/>
    <updated>2012-10-02T22:09:00+08:00</updated>
    <id>http://bcswlmpke.github.com/blog/2012/10/02/uitableview-reloaddata-slow</id>
    <content type="html"><![CDATA[<p>執行 UITableView reloadData，實作 numberOfRowsInSection 回傳 10000：
<code>objc
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
</code>
但實際可視畫面的範圍可能只有 10 列資料顯示，
如果 heightForRowAtIndexPath 有實作，是會被呼叫 10000 次的。
<code>objc
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
</code>
- 當資料量愈多，UI 實際顯示前的所需時間會愈久，
  - 解決方式為不要去覆寫 heightForRowAtIndexPath，</p>

<pre><code>而是直接設定 UITableView 身上的 rowHeight property。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tap手勢的處理]]></title>
    <link href="http://bcswlmpke.github.com/blog/2012/09/19/tap-gesture/"/>
    <updated>2012-09-19T23:11:00+08:00</updated>
    <id>http://bcswlmpke.github.com/blog/2012/09/19/tap-gesture</id>
    <content type="html"><![CDATA[<p>要處理 Single Tap 與 Double Tap 的時候,
除了下面這行要設定以外
<code>objc
  [_singleTap requireGestureRecognizerToFail:_doubleTap];
</code>
還必須設定
<code>objc
  [_singleTap setDelaysTouchesBegan:YES];
  [_doubleTap setDelaysTouchesBegan:YES];
</code>
否則當 Double Tap trigger 時，也會觸發 Single Tap.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC 與 非ARC 在大量資料的情況下的執行速度相差數倍]]></title>
    <link href="http://bcswlmpke.github.com/blog/2012/05/08/arc-nonarc-performance/"/>
    <updated>2012-05-08T21:49:00+08:00</updated>
    <id>http://bcswlmpke.github.com/blog/2012/05/08/arc-nonarc-performance</id>
    <content type="html"><![CDATA[<p>將手邊的 iOS 專案轉換為 ARC，
讓 XCode 於 Compile 時期安插必要的記憶體管理程式碼，
但是它所產生的程式碼是否與我們所想的一樣，
這個就未必了。</p>

<p>我們應該盡可能讓 XCode 幫我們產生正確的記憶體管理程式碼，
但必要時，我們也可以自己對程式碼進行改善！</p>

<p>下面舉一個例子，同樣的程式碼，只是在「ARC」與「非ARC」的情況下編譯執行，
但是兩者所需要的時間是相差數倍的！</p>

<!-- more -->


<p>```objc
  int n = 600000, m = 10000000;</p>

<pre><code>arr = [NSMutableArray new];

for (int i = 0; i &lt; n; i++)
    [arr addObject:[NSNumber numberWithInt:1]];

CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();

id obj = nil;
for (int j = 0; j &lt; m; j++)
{
    obj = [arr objectAtIndex:n - 1];
}

CFAbsoluteTime end = CFAbsoluteTimeGetCurrent();

NSLog(@"end:%lf, start:%lf, diff:%lf", end, start, end - start);

[arr release]; // -&gt; 這一行是「非ARC」需要加上的，但「ARC」沒有這行
</code></pre>

<p>```</p>

<p>執行結果：
<code>objc
非ARC:  end:358178433.846184, start:358178433.753032, diff:0.093152
ARC:    end:358178929.480108, start:358178928.841418, diff:0.638690
可以看出「非ARC」的版本比「ARC」的版本快了近7倍！
</code></p>

<p>但實際上程式是慢在哪呢？
-> 慢在 <code>obj = [arr objectAtIndex:n - 1];</code> 這邊，
XCode 在 Compile 的時候，幫我們安插了類似下面的程式，
```objc
  obj = [[arr objectAtIndex:n - 1] retain];
  [obj autorelease];</p>

<p>如果把「非ARC」的版本修改為上述的程式碼，
則執行結果：
非ARC:  end:358179022.496308, start:358179021.894909, diff:0.601399
是不是就變慢了！
```</p>

<p>因此，XCode 在 Compile 的時候，我想它對於程式的記憶體管理是採取較保守的態度，
如此看來，iOS 5 預設 property 為 strong 也就不意外了！</p>

<p>那麼上面所舉的例子要怎麼解決呢？
-> 我們可以透過 <code>Toll-Free Bridged Types</code> 來解決！
來看一下，我們將 ARC 的版本的程式碼改成下面這個樣子：
將<code>NSArray</code>改成使用<code>CFArrayRef</code>，
這是 Foundation class -> Core Foundation type 的轉換，
這樣的轉換是 Toll-Free 的！
```objc
  __unsafe_unretained id obj;
  for (int j = 0; j &lt; m; j++)
  {</p>

<pre><code>  obj = (__bridge __unsafe_unretained id)CFArrayGetValueAtIndex((__bridge CFArrayRef)arr, n - 1);
</code></pre>

<p>  }
如果把「ARC」的版本修改為上述的程式碼，
則執行結果：
非ARC:  end:358179460.237259, start:358179460.004701, diff:0.232558
是不是就變快了！(但還沒有辦法跟原本的「非ARC」版本一樣快！)
```</p>

<p>所以其實寫程式的時候要多想一下有沒有其它作法，
因為不同的寫法雖然可能達成的結果相同，
但所需要的時間是不同的，
在使用 ARC 時，
如果能清楚的知道自己所創建的物件是被 retain 的狀態，
那麼在傳遞的過程中就可以視需求決定接收此物件是要 retain 或只是 assign，
這樣可以讓 XCode 在 Compile 的時候，
依照我們給它的指示去產生記憶體管理的程式碼，
避免不必要或多餘的效能損失！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[將專案轉換為ARC]]></title>
    <link href="http://bcswlmpke.github.com/blog/2012/05/01/convert-to-arc/"/>
    <updated>2012-05-01T20:28:00+08:00</updated>
    <id>http://bcswlmpke.github.com/blog/2012/05/01/convert-to-arc</id>
    <content type="html"><![CDATA[<h3>Automatic Reference Counting</h3>

<ul>
<li>ARC

<ul>
<li>XCode 4.2 開始支援</li>
<li>Preferences > General > enable Continue building after errors</li>
<li>Edit > Refactor > Convert to Objective-C ARC</li>
<li>using the Apple LLVM compiler</li>
<li>如果轉換失敗，會提供錯誤訊息，等手動修正後，就可以重新啟動 Refactor ARC-conversion workflow
<img src="http://farm8.staticflickr.com/7238/7131702787_9e4cdfcfe1_z.jpg" title="Convert to ARC dialog" alt="Convert to ARC dialog" /></li>
<li>轉換成功後，你可以 review automatic changes，也可以做 snapshot 供之後回復(如果有需要)，然後選擇 Save</li>
</ul>
</li>
</ul>


<!-- more -->


<h3>將手上的專案轉成 ARC 的一些心得整理</h3>

<ul>
<li>不想要轉換為 ARC 的 source file 可加上 <code>-fno-objc-arc</code></li>
<li>不需要自己加上 <code>retain</code>、<code>autorelease</code>、<code>release</code>、<code>[super dealloc]</code></li>
<li>Objects in the struct are unretained
<code>objc
typedef struct {
__unsafe_unretained NSString *name;
} MyStruct;
</code></li>
<li>關於 weak
<code>objc
Becase of 「__weak」 references only work on iOS 5 and above.
If you have the deployment target set to anything earlier, then you'll get the error.
Basically, if you want to deploy to earlier devices you can't use automated 「__weak」 references.
The substitute would be 「__unsafe_unretained」.
</code></li>
<li>NSAutoreleasePool 要修改如下
<code>objc
[Before]
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
[pool drain];
[After]
@autoreleasepool {
}
</code></li>
<li>cast of C pointer type 'void <em>' to Objective-C pointer type 'NSObject </em>' requires a bridged cast <code><strong>bridge</code>
```objc
NSObject<em> myObject = [[NSObject alloc] init];
void</em> myObjectPointer = (</strong>bridge void*)myObject;</li>
</ul>


<p>  void<em> myObjectPointer2 = NULL;
  NSObject</em> myObject2 = (<strong>bridge NSObject*)myObjectPointer2;
<code>
  - assign retained object to unsafe_unretained variable, object will be released after assignment
</code>objc
  請在 @property 加上 strong
  或是在變數名稱前加上 </strong>strong
<code>
  - 發生 leaking 怎麼辦？
</code>objc
  如果發生類似 *** __NSAutoreleaseNoPool(): Object 0x648ad80 of class NSCFString autoreleased with no pool in place - just leaking 的訊息，
  可以透過 Profile -> Leak Tool 找出有問題的地方
<code>
  - 如果是 static method 回傳一個物件，要怎麼釋放？(以 C 所產生的物件為例)
</code>objc
  CFUUIDRef theUUID = CFUUIDCreate(NULL);</p>

<pre><code>CFStringRef strUUID = CFUUIDCreateString(NULL, theUUID);
CFRelease(theUUID);

return (__bridge_transfer NSString *)strUUID; // 釋放原先所有權，將所有權交給 ARC 
</code></pre>

<p><code>
  - id array member instance under ARC
</code>objc
id<ITest> <strong>strong *iArray = nil;
iArray = (id<ITest> </strong>strong *)calloc(sizeof(id<ITest>), Size);
```</p>

<h3>一些不錯的參考連結</h3>

<ul>
<li>Property declarations
<code>objc
「assign」 implies 「__unsafe_unretained」ownership.
「copy」 implies 「__strong」 ownership, as well as the usual behavior of copy semantics on the setter.
「retain」 implies 「__strong」 ownership.
「strong」 implies 「__strong」 ownership.
「unsafe_unretained」 implies 「__unsafe_unretained」 ownership.
weak implies __weak ownership.
</code></li>
<li>Bridged casts
```objc
A bridged cast is a C-style cast annotated with one of three keywords:</li>
</ul>


<p>(<strong>bridge T) op casts the operand to the destination type T. If T is a retainable object pointer type, then op must have a non-retainable pointer type. If T is a non-retainable pointer type, then op must have a retainable object pointer type. Otherwise the cast is ill-formed. There is no transfer of ownership, and ARC inserts no retain operations.
(</strong>bridge_retained T) op casts the operand, which must have retainable object pointer type, to the destination type, which must be a non-retainable pointer type. ARC retains the value, subject to the usual optimizations on local values, and the recipient is responsible for balancing that +1.
(__bridge_transfer T) op casts the operand, which must have non-retainable pointer type, to the destination type, which must be a retainable object pointer type. ARC will release the value at the end of the enclosing full-expression, subject to the usual optimizations on local values.</p>

<p>Using a <strong>bridge_retained or </strong>bridge_transfer cast purely to convince ARC to emit an unbalanced retain or release, respectively, is poor form.
```
  - <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" title="Automatic Reference Counting">Automatic Reference Counting</a>
  - <a href="http://developer.apple.com/library/ios/#releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226" title="Transitioning to ARC Release Notes">Transitioning to ARC Release Notes</a>
  - <a href="http://www.mikeash.com/pyblog/friday-qa-2011-09-30-automatic-reference-counting.html" title="Q&amp;A 2011-09-30: Automatic Reference Counting">Q&amp;A 2011-09-30: Automatic Reference Counting</a></p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS App | Hank學習筆記]]></title>
  <link href="http://bcswlmpke.github.io/blog/categories/ios-app/atom.xml" rel="self"/>
  <link href="http://bcswlmpke.github.io/"/>
  <updated>2013-04-08T16:54:40+08:00</updated>
  <id>http://bcswlmpke.github.io/</id>
  <author>
    <name><![CDATA[Hank Chen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 5 以下不支援 weak reference 遇到的問題]]></title>
    <link href="http://bcswlmpke.github.io/blog/2013/02/20/arc-weak-reference/"/>
    <updated>2013-02-20T20:26:00+08:00</updated>
    <id>http://bcswlmpke.github.io/blog/2013/02/20/arc-weak-reference</id>
    <content type="html"><![CDATA[<p>假設 Application 必須支援 iOS 4.3 的版本，
且是在使用 ARC 的情況下，
由於 iOS 5 才開始支援 weak reference，
那麼在 iOS 5 以下的版本，
可能會遇到下面這段程式有可能 crash 的問題：
```ruby
dispatch_async(dispatch_get_main_queue(), ^{</p>

<pre><code>NSUInteger count = [self.dataSource numberOfItems:self];
</code></pre>

<p>});
```
首先，
因為 weak 屬性在 iOS 4.3 不支援，
所以 dataSource 是一個屬性設為 assign 的 property，
numberOfItems 是一個 delegate 由其它物件進行實作，
如果在開始執行 dispatch_async 這個 block 內的動作之前，
dataSource 已經被釋放了，
這時候輪到執行 block 內的動作時，
會去 retain dataSource，
但因為 dataSource 已經被釋放，所以這個 retain 的動作會造成 crash。</p>

<p>如果 dataSource 這個 property 的屬性為 weak，
那個在 dataSource 被釋放時，
這個 property 就會被設成 nil。
此時應該不會造成 crash 才對。(不曉得這樣的理解有沒有錯)</p>

<p>但因為 main thread 可能處於忙碌狀態，
所以 <code>dispatch_async(dispatch_get_main_queue()</code>的動作
未必會馬上被執行，就有機會遇到上述的問題。</p>

<p>在 iOS 4.3 除了 <a href="https://github.com/mikeash/MAZeroingWeakRef" title="MAZeroingWeakRef">MAZeroingWeakRef</a> 這個方式外，
不曉得在實作上，
大家是用什麼方式來避免上述的情況發生？</p>

<ul>
<li>2013.2.22 更新

<ul>
<li>附註：實作上述 <code>dispatch_async(dispatch_get_main_queue()</code> 的 class 只要在 dealloc 的時候把 self.dataSource 設為 nil, 就可避免 Crash 發生。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITableView 如何調整 Scroll Indicator 的位置？]]></title>
    <link href="http://bcswlmpke.github.io/blog/2012/10/17/change-uitable-scrollindicator-position/"/>
    <updated>2012-10-17T21:48:00+08:00</updated>
    <id>http://bcswlmpke.github.io/blog/2012/10/17/change-uitable-scrollindicator-position</id>
    <content type="html"><![CDATA[<p>嚴格說起來，應該是繼承自 UIScrollView 的都可以調整。
舉例來說，假設要顯示的是垂直方向的 Indicator (預設是開啟的)
<code>ruby
_tableView.showsVerticalScrollIndicator = YES;
</code>
預設位置是在 TableView 的最右邊，假設想放到左邊，或是中間，要怎麼做？
答案是：<code>UIEdgeInsets</code>
<code>ruby
top, left, bottom, right
</code>
接下來要怎麼調整，就看個人需求囉！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITableView 顯示上萬筆資料時，reloadData 很慢的問題]]></title>
    <link href="http://bcswlmpke.github.io/blog/2012/10/02/uitableview-reloaddata-slow/"/>
    <updated>2012-10-02T22:09:00+08:00</updated>
    <id>http://bcswlmpke.github.io/blog/2012/10/02/uitableview-reloaddata-slow</id>
    <content type="html"><![CDATA[<p>執行 UITableView reloadData，實作 numberOfRowsInSection 回傳 10000：
<code>objc
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
</code>
但實際可視畫面的範圍可能只有 10 列資料顯示，
如果 heightForRowAtIndexPath 有實作，是會被呼叫 10000 次的。
<code>objc
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
</code>
- 當資料量愈多，UI 實際顯示前的所需時間會愈久，
  - 解決方式為不要去覆寫 heightForRowAtIndexPath，</p>

<pre><code>而是直接設定 UITableView 身上的 rowHeight property。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tap手勢的處理]]></title>
    <link href="http://bcswlmpke.github.io/blog/2012/09/19/tap-gesture/"/>
    <updated>2012-09-19T23:11:00+08:00</updated>
    <id>http://bcswlmpke.github.io/blog/2012/09/19/tap-gesture</id>
    <content type="html"><![CDATA[<p>要處理 Single Tap 與 Double Tap 的時候,
除了下面這行要設定以外
<code>objc
  [_singleTap requireGestureRecognizerToFail:_doubleTap];
</code>
還必須設定
<code>objc
  [_singleTap setDelaysTouchesBegan:YES];
  [_doubleTap setDelaysTouchesBegan:YES];
</code>
否則當 Double Tap trigger 時，也會觸發 Single Tap.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC 與 非ARC 在大量資料的情況下的執行速度相差數倍]]></title>
    <link href="http://bcswlmpke.github.io/blog/2012/05/08/arc-nonarc-performance/"/>
    <updated>2012-05-08T21:49:00+08:00</updated>
    <id>http://bcswlmpke.github.io/blog/2012/05/08/arc-nonarc-performance</id>
    <content type="html"><![CDATA[<p>將手邊的 iOS 專案轉換為 ARC，
讓 XCode 於 Compile 時期安插必要的記憶體管理程式碼，
但是它所產生的程式碼是否與我們所想的一樣，
這個就未必了。</p>

<p>我們應該盡可能讓 XCode 幫我們產生正確的記憶體管理程式碼，
但必要時，我們也可以自己對程式碼進行改善！</p>

<p>下面舉一個例子，同樣的程式碼，只是在「ARC」與「非ARC」的情況下編譯執行，
但是兩者所需要的時間是相差數倍的！</p>

<!-- more -->


<p>```objc
  int n = 600000, m = 10000000;</p>

<pre><code>arr = [NSMutableArray new];

for (int i = 0; i &lt; n; i++)
    [arr addObject:[NSNumber numberWithInt:1]];

CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();

id obj = nil;
for (int j = 0; j &lt; m; j++)
{
    obj = [arr objectAtIndex:n - 1];
}

CFAbsoluteTime end = CFAbsoluteTimeGetCurrent();

NSLog(@"end:%lf, start:%lf, diff:%lf", end, start, end - start);

[arr release]; // -&gt; 這一行是「非ARC」需要加上的，但「ARC」沒有這行
</code></pre>

<p>```</p>

<p>執行結果：
<code>objc
非ARC:  end:358178433.846184, start:358178433.753032, diff:0.093152
ARC:    end:358178929.480108, start:358178928.841418, diff:0.638690
可以看出「非ARC」的版本比「ARC」的版本快了近7倍！
</code></p>

<p>但實際上程式是慢在哪呢？
-> 慢在 <code>obj = [arr objectAtIndex:n - 1];</code> 這邊，
XCode 在 Compile 的時候，幫我們安插了類似下面的程式，
```objc
  obj = [[arr objectAtIndex:n - 1] retain];
  [obj autorelease];</p>

<p>如果把「非ARC」的版本修改為上述的程式碼，
則執行結果：
非ARC:  end:358179022.496308, start:358179021.894909, diff:0.601399
是不是就變慢了！
```</p>

<p>因此，XCode 在 Compile 的時候，我想它對於程式的記憶體管理是採取較保守的態度，
如此看來，iOS 5 預設 property 為 strong 也就不意外了！</p>

<p>那麼上面所舉的例子要怎麼解決呢？
-> 我們可以透過 <code>Toll-Free Bridged Types</code> 來解決！
來看一下，我們將 ARC 的版本的程式碼改成下面這個樣子：
將<code>NSArray</code>改成使用<code>CFArrayRef</code>，
這是 Foundation class -> Core Foundation type 的轉換，
這樣的轉換是 Toll-Free 的！
```objc
  __unsafe_unretained id obj;
  for (int j = 0; j &lt; m; j++)
  {</p>

<pre><code>  obj = (__bridge __unsafe_unretained id)CFArrayGetValueAtIndex((__bridge CFArrayRef)arr, n - 1);
</code></pre>

<p>  }
如果把「ARC」的版本修改為上述的程式碼，
則執行結果：
非ARC:  end:358179460.237259, start:358179460.004701, diff:0.232558
是不是就變快了！(但還沒有辦法跟原本的「非ARC」版本一樣快！)
```</p>

<p>所以其實寫程式的時候要多想一下有沒有其它作法，
因為不同的寫法雖然可能達成的結果相同，
但所需要的時間是不同的，
在使用 ARC 時，
如果能清楚的知道自己所創建的物件是被 retain 的狀態，
那麼在傳遞的過程中就可以視需求決定接收此物件是要 retain 或只是 assign，
這樣可以讓 XCode 在 Compile 的時候，
依照我們給它的指示去產生記憶體管理的程式碼，
避免不必要或多餘的效能損失！</p>
]]></content>
  </entry>
  
</feed>
